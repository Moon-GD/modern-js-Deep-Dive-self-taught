# Chapter 24 : 클로저, Summary

<br>

### 처음 알았어요 ❗️
#### 1️⃣ 클로저.. 이런 거 였네. 생각보다 쉬움!
- 코딩 면접을 준비할 때 클로저의 정의를 찾아본 적이 있음. 너무 거창하게 보였는데 다시 끄적여보자면..
    - **클로저 : 함수와 함수가 선언된 렉시컬 환경의 조합**
- 근데 이제 너무 쉽게 보임 ㅎㅎ
- 클로저를 설명하기 위해선 아래의 것들을 알아야 한다고 생각한다
    - 렉시컬 환경 (렉시컬 환경을 이해하면 scope chain은 자동으로 따라오기에 scope chain 개념은 생략!)
        - 실행 컨텍스트, 실행 컨텍스트 스택
            - ECMAScript 사양에 따라 4가지 타입으로 나뉘는 source code가 각각 어떻게 실행 컨텍스트 객체를 생성하고 어떤 외부 객체를 바인딩하는지! (꽤나 중요 ⭐️⭐️⭐️)
    <br>
    - JS 엔진
        - 내부 슬롯이란?
        - 코드 실행 방법 및 흐름
- 다시 한 번 클로저의 정의를 살펴보면 크게 두 가지 부분으로 나뉨
    - 1. 함수 : 우리가 흔히들 부르는 클로저가 자체적으로는 함수이기에 하는 말이지~
    - 2. 함수가 선언된 렉시컬 환경 : 클로저가 상위 스코프에 대한 값을 기억할 수 있는 이유는 함수 객체 내부 슬롯 [[ Environment ]]에 외부 렉시컬 환경에 대한 참조 값, 즉, 상위 스코프의 렉시컬 환경을 기입해두기 때문에 함수가 선언된 렉시컬 환경이라는 말이 나오는 거지! 여기서 '❗️선언된❗️'이라는 말이 JS이기에 꽤나 중요함
- 이러한 흐뭇한 숙지를 기반으로 흔히들 클로저의 예시로 나오는 문제를 JS 엔진의 코드 평가 단계부터 클로저가 어떻게 생성이 될 수 있는지의 흐름을 한 번 칠판에 끄적여봐야겠다.
```javascript
const x = 1;

function outer() {
    const x = 10;
    const inner = function() { console.log(x); }
    return inner;
}

// 클로저 함수 반환, 외부 함수의 종료
const closure = outer();
closure(); // ?
```

<br>